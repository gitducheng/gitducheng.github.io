{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-06-27T06:02:02.400Z","updated":"2022-06-27T06:02:02.400Z","comments":true,"path":"about/index.css","permalink":"http://example.com/about/index.css","excerpt":"","text":"body, html { width: 100%; height: 100%; margin: 0; } .container { width: 100%; height: 100%; overflow: auto; position: relative; background: #fff; } .page-header { display: flex; justify-content: space-between; position: absolute; top: 0; z-index: 99; box-sizing: border-box; padding: 10px 36px; width: 100%; border: none; font-size: 18px; -webkit-transition: all 0.2s ease-in-out; -moz-transition: all 0.2s ease-in-out; -o-transition: all 0.2s ease-in-out; -ms-transition: all 0.2s ease-in-out; transition: all 0.2s ease-in-out; } .page-header a { color: #eee; text-decoration: none; } .site-name { text-shadow: 0.1rem 0.1rem 0.2rem rgb(0 0 0 / 15%); font-weight: bold; cursor: pointer; color: #eee; text-decoration: none; } .toggle-menu { display: none; padding-top: 0.5rem; color: #eee; cursor: pointer; -webkit-transition: all 0.2s ease-in-out; -moz-transition: all 0.2s ease-in-out; -o-transition: all 0.2s ease-in-out; -ms-transition: all 0.2s ease-in-out; transition: all 0.2s ease-in-out; } .site-page { position: relative; margin-left: 0.6rem; padding-bottom: 0.3rem; text-shadow: 0.05rem 0.05rem 0.1rem rgb(0 0 0 / 30%); font-size: 14px; cursor: pointer; } .site-page:hover { border-bottom: 2px solid #fff; } .content { width: 100%; height: calc(100% - 50px); margin-top: 50px; display: flex; justify-content: center; align-items: center; } .card { display: flex; justify-content: space-between; width: 800px; height: 600px; border-radius: 7px; background: #fff; overflow: hidden; box-shadow: 0 0 11px 3px rgb(0 0 0 / 15%); } .card_left { flex: 300px 1 0; padding-top: 10%; box-sizing: border-box; background: #f8f8fb66; text-align: center; border-right: 1px solid #e6e6e6; } .card_left .avatar { width: 200px; height: 200px; border-radius: 100%; transform: scale(1); } @keyframes scale { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } } @keyframes scale { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } } .avatar:hover { -moz-box-shadow: 0px 0px 25px #6c97b1; -webkit-box-shadow: 0px 0px 25px #6c97b1; box-shadow: 0px 0px 25px #6c97b1; cursor: pointer; animation: scale 1s; } .card_right { padding: 20px; background: #f8f8fb66; } .right_container { width: 100%; height: 100%; color: #333; overflow: scroll; } .item { margin-top: 30px; } .item:first-child { margin-top: 0; } .title { font-size: 18px; font-weight: 500; color: #222; font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e5e5e5; } .page { font-size: 15px; } .github { width: 40px; height: 40px; border-radius: 100%; } .right_container a { color: #333; } .right_container a:hover { color: #49b1f5; }"},{"title":"关于我","date":"2022-06-02T07:30:10.000Z","updated":"2022-06-28T12:50:41.520Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Pydc的博客 Pydc的Blog 首页 归档 分类 标签 关于 Pydc 一只正在努力学习前端的小菜鸟 关于博客 博客主要记录平时自己学习的知识点。记录工作中遇到的点点滴滴知识点。 关于我 喜欢看热度高的电影，有意思的动漫，已完结的漫画，各个平台的游戏（除了PS），有用的技术，CTF...... 关于工作 2021.7-至&nbsp;&nbsp;&nbsp;今：字节跳动 2019.6-2021.7：中信银行 个人信息 学校：中南民族大学 专业：计算机科学与技术 时间：2019年毕业 职业：web前端开发 城市：北京 联系方式 邮箱：1147914778@qq.com"},{"title":"分类","date":"2022-06-24T06:40:33.432Z","updated":"2022-06-24T06:40:33.432Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-24T03:14:06.843Z","updated":"2022-06-24T03:14:06.843Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"带你了解边缘计算节点","slug":"带你了解边缘计算节点","date":"2022-07-28T08:00:04.000Z","updated":"2022-07-29T02:53:01.792Z","comments":true,"path":"2022/07/28/带你了解边缘计算节点/","link":"","permalink":"http://example.com/2022/07/28/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9/","excerpt":"","text":"一、背景本篇将边缘计算节点功能分为功能类和监控类，功能类包括对虚机的创建、修改、删除等，监控类包括平台对用户虚机的监控。主要目的是给大家通俗易懂的介绍边缘计算节点该如何创建，每个功能模块的作用。 二、功能类边缘服务（云服务）配置虚机选择实例规格（电脑硬件配置）首先按架构，大致分为x86、裸金属、ARM，每种架构下再细分各种特性规格（通用型、计算型、GPU型…）。 x86架构 X86架构是微处理器执行的计算机语言指令集，指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。 最为我们所知的就是intel的CPU，有i3、i5、i7、i9等系列。 ARM架构 进阶精简指令集机器，是一个32位精简指令集（RISC）处理器架构。 最为我们所知的就是Apple的M1、M2。 裸金属服务器 一台既具有传统物理服务器特点的硬件设备，又具备云计算技术的虚拟化服务功能，是硬件和软件优势结合的产物。 不是一种指令集架构，因为它不是以指令集划分的，而是以传统虚拟机为对比划分出来的一种服务器。例如一般我们创建虚拟机，首先需要有一台真实电脑，电脑是windows或linux系统，再在电脑安装VM ware软件来创建虚拟机。但是，裸金属没有操作系统，也就是没有windows或Linux，创建虚拟机的软件直接安装在硬件上。原本的VM控制软件由安装在系统上，变成了安装在电脑硬件上。 这样的服务器有什么优势？ 1、稳定性 如果VM控制软件是安装在系统，系统万一蓝屏（死机），那么所有跑在该实体电脑上的虚拟机都会挂掉，一些对系统稳定性、安全性和高标准敏感度高的场合是不允许这种情况的。那么回来说说裸金属服务器，因为VM控制软件运行在硬件上，少了一层操作系统，再者软件稳定性优于系统，所以裸金属服务器是一些企业用户的首选。 2、隔离性 安装在系统上的虚拟机可以访问到系统上的资源，虽然一般会被禁止，但不能保证安全。裸金属服务器因为没有操作系统，虚拟机之间是不可访问的，所以安全性大于传统虚拟机。 规格分类 类型 特点 CPU和内存配比 通用型 适用于中小型数据库系统、搜索集群，数据分析和计算，计算集群、依赖内存的数据处理等场景 1:4 计算型 适用于数据分析、分布式计算，Web前端等场景 1:2 内存型 适用于高性能边缘数据服务，内存数据服务或分布式内存缓存等场景 1:8 本地SSD&#x2F;HDD型 适用于对读写有高要求场景 1:4、1:8 GPU型 适用于AI训练、影视渲染等场景 1:4 镜像（系统）有CentOS、Debian、Ubuntu、Windows几类，选择合适的即可，除个别规格需要指定系统，没啥区别。 选择硬盘（HDD、SSD）选择性能适合的就行。 配置网络（网络类型、带宽）创建的虚机为IPv4，还是同时有IPv4、IPv6地址，设置网络带宽大小。 选择节点（地区、运营商、集群）选择虚机创建的地区（华北、华南、华东…），无太大区别。 修改配置信息启用IPv6云服务启用IPv6后，新增的实例会启用IPv6，已创建的IPv4实例会在下次重启后启用IPv6。 修改带宽峰值调整带宽峰值大小，实例需重启生效。 批量启、停、删除以服务为单位，进行虚机的常规批量操作。 实例管理新增实例安装所选云服务的配置，在该服务下新增实例。 VNC用于登录进入虚机。 启、停、删除…将所选虚机进行常规批量操作。 镜像管理可上传自定义镜像，创建云服务时可以使用自定义镜像。 私有网络（VPC） 虚拟私有云（Virtual Private Cloud，以下简称VPC），为弹性云服务器构建隔离的、用户自主配置和管理的虚拟网络环境，提升用户云中资源的安全性，简化用户的网络部署。 简单理解为用户在某一地区节点上的标识，不可进行操作。 四层&#x2F;七层负载均衡负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行配置负载均衡，需要绑定eip和实例才能生效。 弹性公网IP（EIP） 弹性公网IP（Elastic IP Address，简称EIP）是可以独立购买和持有的公网IP地址资源。 用作负载均衡对外暴露使用的IP。 外网防火墙配置流量的出入向规则，例如限制IP地址、端口、协议等。 NAT网关 NAT网关是一种网络地址转换服务，提供NAT代理（SNAT和DNAT）能力。SNAT网关提供公网地址转换服务，而DNAT网关提供私网地址转换服务。 SNAT：内部实例可以访问公网服务，公网服务不能访问内部实例。 DNAT：内部实例对外提供服务。 适用场景：一般用于实例没有公网IP，只有私网IP的情况下。 VPC组网（边缘互联）简单来说，将两个VPC绑定在一起，两个VPC下的虚机可以通信。 适用场景： • 原始vpc的时候网段建小了，网段不够分； • VPC内业务所需设备数超过500台，vpc内目前承诺可容纳500台设备； 三、监控类数据监控可查询实例的CPU、带宽、网络使用情况。 报警服务可配置规则监控实例的使用情况，如CPU使用率、网络丢包率，超过一定百分比进行报警。 计费用量可查询用户的实例对资源的使用情况。 系统事件记录用户的实例、LB、EIP等的重启、删除等操作。","categories":[{"name":"云主机","slug":"云主机","permalink":"http://example.com/categories/%E4%BA%91%E4%B8%BB%E6%9C%BA/"}],"tags":[{"name":"云主机","slug":"云主机","permalink":"http://example.com/tags/%E4%BA%91%E4%B8%BB%E6%9C%BA/"}]},{"title":"service worker入门","slug":"service-worker入门","date":"2022-06-28T11:31:36.000Z","updated":"2022-06-28T12:29:47.706Z","comments":true,"path":"2022/06/28/service-worker入门/","link":"","permalink":"http://example.com/2022/06/28/service-worker%E5%85%A5%E9%97%A8/","excerpt":"","text":"什么是service worker一句话概括就是：独立于网页运行在浏览器后台的 js 脚本，可以用来监听页面的 fetch 事件并针对 request&#x2F;response 进行资源缓存。 可以做什么？ 本质上充当Web应用程序（服务器）与浏览器之间的代理服务器（可以拦截全站的请求，并作出相应的动作-&gt;由开发者指定的动作） 创建有效的离线体验（将一些不常更新的内容缓存在浏览器，提高访问体验） 可以访问cache和indexDB 支持推送 可以让开发者自己控制管理缓存的内容以及版本 注册提前准备好一个js文件（sw.js），内容如下 1console.log(&#x27;sw.js&#x27;) 在html中进行service worker注册 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;service worker register demo&lt;/h1&gt;&lt;script&gt; window.onload = function () &#123; navigator.serviceWorker.register(&#x27;/sw.js&#x27;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上简单的代码就完成了service worker的注册。 监听fetch将以下代码写入 sw.js 文件中，重新注册 service worker 123self.addEventListener(&#x27;fetch&#x27;, (event) =&gt; &#123; console.log(&#x27;event&#x27;,event)&#125;) 向html里面增加发送请求的代码，如下 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;service worker fetch event demo&lt;/h1&gt;&lt;div&gt; &lt;button id=&quot;request&quot;&gt;get user info&lt;/button&gt; &lt;pre id=&quot;pre&quot;&gt;&lt;/pre&gt;&lt;/div&gt;&lt;script&gt; const request = document.getElementById(&#x27;request&#x27;) const pre = document.getElementById(&#x27;pre&#x27;) window.onload = function () &#123; navigator.serviceWorker.register(&#x27;/sw.js&#x27;) &#125; request.addEventListener(&#x27;click&#x27;, () =&gt; &#123; axios.get(&#x27;/api/user&#x27;).then(response =&gt; &#123; pre.innerHTML = JSON.stringify(response.data) &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同时我们在本地起一个node服务，用于接收请求 12345678910111213141516171819202122const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/sw.js&#x27;, function (request, response) &#123; response.sendFile(__dirname + &#x27;/sw.js&#x27;);&#125;);app.get(&#x27;/api/user&#x27;, function (_, response) &#123; response.json(&#123; username: &#x27;xx&#x27;, age: 18 &#125;)&#125;)app.get(&#x27;*&#x27;, function (request, response) &#123; response.sendFile(__dirname + &#x27;/index.html&#x27;);&#125;);const listener = app.listen(process.env.PORT, function () &#123; console.log(&#x27;Your app is listening on port &#x27; + listener.address().port);&#125;); 启动服务之后，点击button发送请求，可以看到控制台会打印event对象。 在这个 request 对象中，咱们是能拿到 request 相关信息以及更多事件相关信息，根据这些信息咱们就能进行请求的改写及其他各种操作。 修改fetch返回值fetch event 对象提供了 respondWith api 允许在 service worker 中修改 response。 12345678// 修改sw.js中的fetch处理self.addEventListener(&#x27;fetch&#x27;,(event) =&gt; &#123; if(event.request.url.endsWith(&#x27;/api/user&#x27;))&#123; event.respondWith(new Response(JSON.stringify(&#123; username: &#x27;我固定了&#x27; &#125;))) &#125;&#125;) 异步修改respondWith 还可以接受 Promise 实例用于异步返回 response，比如说在我们需要拦截并发送新的请求时需要等待 service worker 中新请求的数据返回又或者说其他场景。 以下模拟了，延迟 3s 后返回篡改的 response。 1234567891011121314151617181920function sleep(rtn, ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(rtn) &#125;, ms) &#125;)&#125;self.addEventListener(&#x27;fetch&#x27;, (event) =&gt; &#123; if (event.request.url.endsWith(&#x27;/api/user&#x27;)) &#123; event.respondWith( sleep( new Response(JSON.stringify(&#123; username: &#x27;我固定了&#x27; &#125;)), 3000 ), ) &#125;&#125;) 缓存资源（cache）说完 fetch 事件，咱们来看看 Cache 对象. 首先给大家截了一张图让大家对缓存数据有个基本的结构了解，主要关心的点在于左侧 Cache 面板的 Cache Storage 部分。 这里咱们需要区分 CacheStorage 以及 Cache 的区别，CacheStorage 是所有 Cache 的住目录，Cache 为 CacheStorage 下属缓存子目录，类比到数据库的话，可以将 CacheStorage 比做 DB，Cache 比做 Table，大概是这么个关系。 可以使用 CacheStorage.open(cacheName) 的方式打开&#x2F;新建具体的某一个 Cache 对象并进行相应管理。 添加单个缓存先通过 caches.open 打开名为 api 的 cache 对象，在通过 add 方案添加相应缓存，service worker 会自动发起相关请求并缓存 response。 123caches.open(&#x27;api&#x27;).then(cache =&gt; &#123; return cache.add(&#x27;/api/user&#x27;)&#125;) 一次缓存多个可以调用 cache 对象的 addAll 方法 123456caches.open(&#x27;api&#x27;).then(cache =&gt; &#123; return cache.addAll([ &#x27;/&#x27;, &#x27;/api/user&#x27; ])&#125;) 删除缓存调用 Cache 对象的 delete 方法可以删除指定缓存 12345678// sw.jsself.addEventListener(&#x27;message&#x27;, e =&gt; &#123; if (e.data === &#x27;delete cache&#x27;) &#123; caches.open(&#x27;api&#x27;).then(cache =&gt; &#123; return cache.delete(&#x27;/api/user&#x27;) &#125;) &#125;&#125;) 123456// main.jsdel.addEventListener(&#x27;click&#x27;,() =&gt; &#123; window.navigator.serviceWorker.getRegistration().then(registration =&gt; &#123; registration.active.postMessage(&#x27;delete cache&#x27;) &#125;)&#125;) 实际应用网络请求优先，网络出问题时再使用cache 1234567891011121314151617181920212223242526self.addEventListener(&#x27;fetch&#x27;, e =&gt; &#123; const &#123; request &#125; = e if (request.url.endsWith(&#x27;/api/user&#x27;)) &#123; e.respondWith( new Promise(async (resolve, reject) =&gt; &#123; try &#123; const response = await fetch(request.clone()) // 每次请求，更新cache内容 caches.open(&#x27;api&#x27;).then(cache =&gt; &#123; cache.put(&#x27;/api/user&#x27;, response.clone()) &#125;) resolve(response.clone()) &#125; catch (e) &#123; // 请求出错，使用缓存 caches.match(request).then(cache =&gt; &#123; if (cache) &#123; resolve(cache) &#125; else &#123; reject(e) &#125; &#125;) &#125; &#125;) ) &#125;&#125;) 生命周期 首先一个 service worker 的起点必然是注册的开始，既我们在页面调用 navigator.serviceWorker.register 的开始。浏览器开始下载 sw 脚本并开始解析执行 然后进入到安装阶段，此阶段可以在 sw 脚本中监听 install 事件，并在 install 事件中进行 precache 进行前置资源缓存或者进行其他事项 install 安装完成之后，浏览器会判断当前 scope 是否存在已经激活的 service worker 如果存在那么新安装的 service worker 将进入等待阶段 等待当前激活的 service worker 不再对任一页面进行控制 或者等待新安装 service worker 是否有 self.skipWaiting()的执行 又或者等待某个页面中是否执行了 registration.update() 的执行 进入激活阶段的 service worker 才能托管页面的一些行为 注意事项支持service worker的浏览器 支持https或本地开发注册 service worker 需要使用到 navigator.serviceWorker api，但是会发现在使用 http 协议打开页面的时候该 api 变成了 undefined。 这对开发调试的时候并不是太友好，所以在除了 https 的场景外，浏览器在 localhost 以及 127.0.0.1:port 这两个场景下保留了 navigator.serviceWorker api 方便开发阶段的 debug。 workboxWorkbox 是 Google Chrome 开源的一套 service worker 解决方案，对 service worker 可能遇到的各种场景进行了相应封装，极大的降低了上手成本以及使用成本。 参考资料https://www.wenjiangs.com/doc/lo6qjpcs","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Vue2.x的生命周期详解","slug":"Vue2-x的生命周期详解","date":"2022-06-17T11:31:36.000Z","updated":"2022-06-27T06:49:00.428Z","comments":true,"path":"2022/06/17/Vue2-x的生命周期详解/","link":"","permalink":"http://example.com/2022/06/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"使用Vue开发已经有一段时间了。但发现自己对vue的理解还是不深刻。于是想着从观看Vue文档开始。在阅读文档之前，觉得需要先了解整个Vue的生命周期，清楚的认识到Vue在每个阶段的钩子函数没这样才能更好的让我们去使用Vue。 我们先来看一张图，上面解释每个步骤是做什么的。可以只看这一张图就可以明白Vue实例的整个流程。 每个Vue实例在被创建之前都要经历过一系列的初始化过程，这个过程就是Vue的生命周期。浅显的来说，生命周期的钩子函数就是回调函数，在不同的阶段有不同的回调函数供用户处理自定义的事件。也可以说生命周期是一套流程，而这套流程里面的方法会有先后顺序的执行（调用就执行，不调用就不执行）。 生命周期钩子从上面的图中会看到生个vue的生命周期钩子： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 当然除了实例的生命周期，还有其他的： activated： keep-alive 缓存组件激活时使用 deactivated： keep-alice 缓存组件停用时使用 errorCaptured： 捕获一个来自子孙组件的错误时调用 beforeCreate 之前在beforeCreate生命周期之前。首先是使用new Vue来开始创建一个Vue实例、接下来会初始化这个实例的生命周期事件。如下图： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, beforeCreate () &#123; console.log(&quot;------beforeCreate------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data); console.log(&quot;methods:&quot;, this.getMessage); &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 打印结果： 1234------beforeCreate------el: undefineddata: undefinedmethods: undefined beforeCreate 和 created 之间在这个生命周期之前，会初始化当前实例上的data 和methods。说明created的时候数据已经绑定，是可以访问到了。在这里可以做ajax请求了。 注意：这里还没有 el 选项。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, beforeCreate () &#123; console.log(&quot;------beforeCreate------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data); console.log(&quot;methods:&quot;, this.getMessage); &#125;, created () &#123; console.log(&quot;------created------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data.message); console.log(&quot;methods:&quot;, this.getMessage()); &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 结果打印： 12345678------beforeCreate------el: undefineddata: undefinedmethods: undefined------created------el: undefineddata: Pydcmethods: 方法返回：Pydc 可以看出，created可以获取data和methods created 和 beforeMount 之间的生命周期 这阶段里面首先会判断是否有el选项。如果有的话，那么继续往下编译，如果没有el选项。则停止编辑。也就意味停止了生命周期。直到该Vue实例上调用了Vm.$mount(el)。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; // el: &#x27;#app&#x27;, // 被注释掉了 data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, created() &#123; console.log(&quot;------created--------&quot;) &#125;, beforeMount() &#123; console.log(&quot;------beforeMount------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data.message) console.log(&quot;methods:&quot;, this.getMessage()); &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 结果打印： 1------created-------- 手动调用实例的Vm。$mount(#app): 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; // el: &#x27;#app&#x27;, // 被注释掉了 data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, created() &#123; console.log(&quot;------created--------&quot;) &#125;, beforeMount() &#123; console.log(&quot;------beforeMount------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data.message) console.log(&quot;methods:&quot;, this.getMessage()); &#125;, &#125;) vm.$mount(&quot;#app&quot;); // 手动调用了 Vm.$mount(el)&lt;/script&gt;&lt;/html&gt; 结果打印： 然后会判断是否有template。有没有template对生命周期没有影响。 如果有template则直接作为模板编译成render函数； 如果没有template则直接将外部的html作为模板编译； 注意：template模板的优先级要高于外部html的优先级。 如下的例子： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;这是外部的html模板:&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, template: &quot;&lt;span&gt;这是内部的模板：&#123;&#123;message&#125;&#125;&lt;/span&gt;&quot;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 打开之后，我们看到的页面文案是：”这是内部的模板：Pydc” 如果我们把template 删除掉那么就会显示：”这是外部的html模板:Pydc”6 beforeMount 和 mounted之前的生命周期 这期间Vue实例对象添加$el。把内存中渲染好的html 替换到页面上。覆盖$el指定的页面。因为在这之前的beforeCreate生命周期打印的el还是undefined。 mounted生命周期12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;这是外部的html模板:&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, template: &quot;&lt;span&gt;这是内部的模板：&#123;&#123;message&#125;&#125;&lt;/span&gt;&quot;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, mounted() &#123; console.log(&quot;--------mounted--------&quot;); console.log(&quot;el:&quot;, this.$el); &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 打印结果为： 12--------mounted--------el: &lt;span&gt;​这是内部的模板：Pydc​&lt;/span&gt;​ 在这之前的span标签的名字是 占位的。这是JavaScript中的虚拟DOM形式存在的。在mounted之后就可以看到了内容发生了变化。 beforeUpdate 和 updated 之间的生命周期 从图中可以看出来， 当data的数据发生了变化，先会触发beforeUpdate钩子。注意这时候页面的视图还没更新。然后才重新渲染组件。最后调用updated。调用完之后。视图和data都是最新的。 我们看下面的例子： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;这是外部的html模板:&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;老的数据&quot; &#125;, beforeUpdate() &#123; console.log(&quot;--------beforeUpdate--------&quot;); console.log(&quot;el:&quot;, this.$el); &#125;, updated() &#123; console.log(&quot;--------updated--------&quot;); console.log(&quot;el:&quot;, this.$el); &#125; &#125;) vm.message = &quot;新的数据&quot;;&lt;/script&gt;&lt;/html&gt; 打印结果： 当数据data有改变的（ vm.message &#x3D; “新的数据”）。就会分别触发beforeUpdate 和 updated。 beforeDestroy 和 destroyed 之间的生命周期 beforeDestroy 生命周期是在实例被销毁之前调用。在这一步，实例仍然是可用的。 destroyed生命周期是在实例销毁之后调用。调用后。Vue实例所指的所有东西都会被解除绑定。所有的事件也会被移除。所有的子实例也会被销毁。 activatedkeep-alive 缓存组件激活的时候使用 deactivated keep-alive 缓存组件停用时使用 errorCaptured捕获子孙组件的错误时调用 数据请求在created和mouted的区别created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成，mounted是在页面dom节点渲染完毕之后就立刻执行的，触发时机上created是比mounted要更早的：两者相同点：都能拿到实例对象的属性和方法；讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在create生命周期当中","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Chrome 101新特性：fetchpriority","slug":"Chrome 101新特性：fetchpriority","date":"2022-06-12T02:10:00.000Z","updated":"2022-07-18T14:08:28.856Z","comments":true,"path":"2022/06/12/Chrome 101新特性：fetchpriority/","link":"","permalink":"http://example.com/2022/06/12/Chrome%20101%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Afetchpriority/","excerpt":"","text":"背景最近发现Chrome 101版本更新了一个新特性，所以顺便学习总结了一下。 预加载可以在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。但是，一些情况下，我们还需要对预加载的资源优先级进行进一步的划分。预加载对资源优先级的设置并不能满足，于是有了可以对资源优先级进行补充的fetchpriority。 为了解决什么问题 影响资源获取的优先级； 补充预加载后的资源加载顺序；优先级指示资源对浏览器的相对优先级，它们可以实现最佳加载并改善Web用户体验。 浏览器中的资源优先级当浏览器开始解析网页，并开始下载图片、js 以及 css 等资源的时候，浏览器会为每个资源分配一个代表资源下载优先级的 fetch priority 标志。而资源下载的顺序就取决于这个优先级标志，这个优先级标志的计算逻辑会受很多因素的影响： CSS、字体、脚本、图像和第三方资源分配了不同的优先级。 引用文档中资源的位置或顺序也会影响资源的优先级。 预加载资源提示有助于浏览器更快地发现资源，从而在文档加载之前加载资源并影响优先级。 脚本设置async或defer影响优先级计算。考虑以上因素，下表统计了Chrome中大多数资源的优先级和顺序： 浏览器按照资源被发现的顺序下载资源，可以在 DevTools Network 下看到分配给不同资源的优先级： 但是并不是所有情况下默认的下载优先级都是最佳的。 什么时候需要优先提示技术应用场景： 同时有几个首屏图像，但它们不需要具有相同的优先级。例如，在图像轮播中，只有第一个可见图像需要比其他图像更高的优先级； 可见区域的图像为低优先级，但布局完成后，Chrome发现它们在视图中，会自动提高它们的优先级。这时候页面会增加加载图像的延迟，使用优先级提示可以让图像以高优先级开始，并更早地开始加载。 将脚本声明为async或defer告诉浏览器异步加载它们，这时脚本也被分配了“低”优先级。但是希望在确保异步下载的同时提高它们的优先级，特别是对于任何对用户体验至关重要的脚本。 浏览器为 CSS 和字体分配了高优先级，但所有这些资源可能并不同样重要，可以使用优先级提示来降低其中一些资源的优先级。 使用fetch()异步获取资源或数据时，浏览器为 Fetch 分配了高优先级。在某些情况下，我们可能不希望以高优先级执行所有请求，而是使用不同的优先级提示。例如，后台 API 调用可以标记为低优先级，交互式 API 调用可以标记为高优先级。 在资源争夺可用网络带宽的环境中，优先级带来的显着收益将更加相关。 如何使用fetchpriority属性fetchpriority 属性可以指定三个值： high：你认为该资源具有高优先级，并希望浏览器对其进行优先级排序； low：你认为该资源的优先级较低，并希望浏览器降低其优先级； auto：采用浏览器的默认优先级； 使用示例： 123456789101112131415&lt;!-- We don&#x27;t want a high priority for this above-the-fold image --&gt;&lt;img src=&quot;/images/in_viewport_but_not_important.svg&quot; fetchpriority=&quot;low&quot; alt=&quot;I&#x27;m an unimportant image!&quot;&gt;&lt;!-- We want to initiate an early fetch for a resource, but also deprioritize it --&gt;&lt;link rel=&quot;preload&quot; href=&quot;/js/script.js&quot; as=&quot;script&quot; fetchpriority=&quot;low&quot;&gt;&lt;script&gt; fetch(&#x27;https://example.com/&#x27;, &#123;priority: &#x27;low&#x27;&#125;) .then(data =&gt; &#123; // Trigger a low priority fetch &#125;);&lt;/script&gt;&lt;!-- The third-party contents of this iframe can load with a low priority --&gt;&lt;iframe src=&quot;https://example.com&quot; width=&quot;600&quot; height=&quot;400&quot; fetchpriority=&quot;low&quot;&gt;&lt;/iframe&gt; 实际应用：提升 LCP 图像的优先级 比如，在 Google Flights 这个网页中，影响它 LCP 指标的主要原因是它的背景图片，现在我们用 fetchpriority 属性提升它加载的优先级： 1&lt;img src=&quot;lcp-image.jpg&quot; fetchpriority=&quot;high&quot;&gt; 当优先级设置为高时，LCP从2.6秒提高到1.9秒 降低首屏图片的优先级使用 fetchpriority 属性降低可能不重要的首屏图片的优先级，比如轮播图中后面的图片： 123456&lt;ul class=&quot;carousel&quot;&gt; &lt;img src=&quot;img/carousel-1.jpg&quot; fetchpriority=&quot;high&quot;&gt; &lt;img src=&quot;img/carousel-2.jpg&quot; fetchpriority=&quot;low&quot;&gt; &lt;img src=&quot;img/carousel-3.jpg&quot; fetchpriority=&quot;low&quot;&gt; &lt;img src=&quot;img/carousel-4.jpg&quot; fetchpriority=&quot;low&quot;&gt;&lt;/ul&gt; 降低预加载资源的优先级想要阻止预加载资源和其他关键资源的竞争，可以降低其优先级： 123456&lt;!-- Lower priority only for non-critical preloaded scripts --&gt;&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;critical-script.js&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;/js/script.js&quot; as=&quot;script&quot; fetchpriority=&quot;low&quot;&gt;&lt;!-- Preload CSS without blocking other resources --&gt;&lt;link rel=&quot;preload&quot; as=&quot;style&quot; href=&quot;theme.css&quot; fetchpriority=&quot;low&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt; 调整脚本的优先级如果页面上有一些必要的交互脚本，但不需要阻塞其他资源，可以把它们标记为具有高优先级，同时异步加载它们： 1&lt;script src=&quot;async_but_important.js&quot; async importance=&quot;high&quot;&gt;&lt;/script&gt; 如果脚本依赖于特定的 DOM 节点，则它们不能被标记为异步加载。但是如果它们不是首屏渲染必备的，可以降低它们的优先级： 1&lt;script src=&quot;blocking_but_unimportant.js&quot; importance=&quot;low&quot;&gt;&lt;/script&gt; 调整fetch的优先级浏览器默认会以高优先级执行 fetch 请求，可以降低不太关键的数据请求的优先级： 12345// Important validation data (high by default)let authenticate = await fetch(&#x27;/user&#x27;);// Less important content data (suggested low)let suggestedContent = await fetch(&#x27;/content/suggested&#x27;, &#123;priority: &#x27;low&#x27;&#125;); 注意事项优先级提示可以提高特定用例中的性能，有一些事情需要注意： fetchpriority属性是一个提示，而不是一个指令。浏览器会尽量尊重开发者的偏好，如果发生冲突，浏览器也可能会根据需要应用其对资源优先级的偏好。 优先级提示不应与预加载混淆，它们都是不同的，因为： 预加载是强制获取而不是提示。 预加载更容易被观察和测量。 优先级提示可以通过增加优先级的粒度来补充预加载。如果已经在页面顶部为 LCP 图像指定了预加载，那么“高”优先级提示可能不会带来显着的收益。但是，如果预加载是在其他不太重要的资源之后，那么高优先级的提示可以提高LCP。如果关键图像是 CSS 背景图像，则应使用fetchpriority &#x3D; “high”。 CDN没有统一实现 HTTP&#x2F;2 优先级。 补充说明importance优先提示首先在 2018 年作为原始试验在 Chrome 中进行了试验，然后在 2021 年再次使用该importance属性。作为 Web 标准流程的一部分，在HTML中该属性已更改为fetchpriority，JavaScript中为priority 。 fetchpriority 浏览器兼容性目前，优先级提示仅在基于 Chromium 的浏览器中可用。其他浏览器引擎或早期版本的 Chromium 浏览器将忽略该属性并使用其默认的优先级启发式。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"简单实现一个微前端框架","slug":"简单实现一个微前端框架","date":"2022-05-02T10:11:20.000Z","updated":"2022-06-28T12:36:03.324Z","comments":true,"path":"2022/05/02/简单实现一个微前端框架/","link":"","permalink":"http://example.com/2022/05/02/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/","excerpt":"","text":"https://blog.csdn.net/q411020382/article/details/122651852","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"React hook 学习","slug":"React-hook-学习","date":"2021-09-14T13:27:32.000Z","updated":"2022-07-19T13:18:47.892Z","comments":true,"path":"2021/09/14/React-hook-学习/","link":"","permalink":"http://example.com/2021/09/14/React-hook-%E5%AD%A6%E4%B9%A0/","excerpt":"又要开始抗起React 搬砖了，多了很多的 hook， 嗯 😔，先好好学学吧！做个简单的学习记录。读完本篇文章可以了解到： 什么是 Hook? Hook 解决什么问题? Hook有哪些规格？ React内置了哪些 Hook？","text":"又要开始抗起React 搬砖了，多了很多的 hook， 嗯 😔，先好好学学吧！做个简单的学习记录。读完本篇文章可以了解到： 什么是 Hook? Hook 解决什么问题? Hook有哪些规格？ React内置了哪些 Hook？ 什么是 Hook？Hook 是React 16.8的新特性。它的主要作用是让我们在不写 class的情况下可以使用state和React本身的一些特性。 Hook本质上就是一个函数， 它有自己的状态管理，生命周期管理，状态共享等；如下面的Hook： useState useEffect useContext useReducer Hook 解决什么问题我们来看看Hook到底解决了什么问题。 我们首先来看 这两种组件类型有什么区别： See the Pen test1 by gitducheng (@gitducheng) on CodePen. See the Pen test2 by gitducheng (@gitducheng) on CodePen. 由上面的例子我们可以看出： class 组件特点： 有组件实例 有生命周期 有state 和 setState 函数组件的特点： 没有组件实例 没有有生命周期 没有state 和 setState；只能接收 props 函数组件只是一个纯函数， 执行完就会被销毁，无法存储 state class组件存在的问题是什么呢？ 大型的组件很难拆分和重构 相同的业务逻辑分散到各个方法中，变得混乱 复用的逻辑变得很复杂 所以 React 更提倡函数式编程，因为函数更加灵活，更容易拆分。但是呢！！！！ 函数组件又太简单， 所以才出现了 hook；hook 就是用来增强函数组件的功能的 Hook 的规则Hook 有两条比较重要的规则； 只能在最最顶层使用Hook 只有在 React 组件中才能调用 为什么需要在最顶层使用??????? 其实是为了保证多个 hook 的调用顺序是一致的 也就是说不要**循环，条件或者嵌套的函数中调用hook**。这样可以做到各个hook 每一次渲染中， 调用的顺序是一致的。 123456789function Name() &#123; useState(&quot;1111&quot;); if (name === &quot;xxx&quot;) &#123; // 错误，没有在最顶层调用 useState(&quot;22222&quot;); &#125; // 会出现未知问题，有时候是第二次调用，有时候是第三次 useState(&quot;3333&quot;);&#125; 为什么我们需要保证多个 hook 的调用顺序一致呢？ 这个就跟React 实现的 hook 的原理有关了。因为每次在渲染的时候， React会把所有调用的hook 存储起来。 关于这一块原理感兴趣， 可以看看这篇文章 React Hooks 原理， 写得很好。 React 也发布了 ESlint 插件 eslint-plugin-react-hooks帮助我们强制执行这两条规则。 123456&#123; &quot;extends&quot;: [ // ... &quot;plugin:react-hooks/recommended&quot; ]&#125; React 内置的 Hook我们来看看React 内置的hook 有哪些： useState 状态管理 useEffect 生命周期管理 useContext 共享状态数据 useMemo 缓存值 useRef 获取Dom 操作 useCallback 缓存函数 useImperativeHandle 子组件暴露值&#x2F;方法 useLayoutEffect 完成副作用操作，会阻塞浏览器绘制 useReducer 与 redux 一样 下面我们来分别学习一下这些内置的Hook useState在 class 组件中，我们获取 state 是从this.state 中获取的。但是在函数组件中是没有 this 的。 所以在函数组件中就可以使用hook 提供的 useState来管理和维护 state。 使用1const [name, setName] = useState(initName); useState: 定义 state 变量的函数hook name: 定义出来的变量 setName：为更新 satate 方法 initName: name变量的初始值 使用useState 可以定义一个变量，如上我们这个变量叫name。useState有一个参数（如上initName），为变量的初始值。初始值可以根据我们自己的需要使用不同类型（即可以是字符串，数字， 布尔值等， 不一定是非是对象）useState的返回值是返回当前的state和更新state的函数。 举个 🌰 See the Pen react hooks基本用法 by gitducheng (@gitducheng) on CodePen. --- useEffectuseEffect 可以看作是函数式组件的生命周期管理，因为在函数式组件中无法使用生命周期。这就可以使用useEffect来进行管理了。 useEffect主要管理三个生命周期函数： componentDidmount 组件第一次渲染完成，此时 dom 节点已经生成，可以在这里调用 ajax 请求，返回数据setState后组件会重新渲染 componentDidUpdate 组件更新完毕后，react 只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，componentDidUpdate(prevProps,prevState这里可以拿到prevProps和prevState，即更新前的 props 和 state。 componentWillUnmount 组件销毁之后触发的生命周期。一般用来： 清除在组件中的定时器（setTimeout,setInterval） 移除组件中的监听（removeEventListener） 取消还没有请求结果的ajax请求 无需清除的 effect有时候我们只希望在React更新DOM之后运行一些额外的代码，那么只需要在class 组件生命周期componentDidmount和componentDidUpdate中执行即可。 那么在useEffect中如何写呢？我们可以这么写： 123useEffect(() =&gt; &#123; // 默认会执行这部分，相当于 class 组件的生命周期（componentDidmount， componentDidUpdate）&#125;, []); 需要清除 effect当我们希望在一个组件销毁的时候执行一些逻辑处理。那么就需要在 class 组件的 componentWillUnmount 执行即可。 那么在useEffect中如何写呢？我们可以这么写： 12345useEffect(() =&gt; &#123; return () =&gt; &#123; // 组件销毁时执行的函数 &#125;;&#125;, []); 监听 state 的变化当我们需要监听的state的变化然后做一些处理的时候,我们可以这么写： 1234useEffect(() =&gt; &#123; // 监听num，count 状态的变化， 变化了则执行里面的代码 // 不监听时为空 [] , 或者不写&#125;, [num, count]); 举个 🌰 See the Pen react useEffect by gitducheng (@gitducheng) on CodePen. useRefuseRef返回一个 ref 对象。这个对象的.current属性被初始化为useRef传入的参数。该对象在整个生命周期内持续存在。 1const domRef = useRef(initialValue); ref 对象:ref是React提供的用来操纵React组件实例或者DOM元素的接口。 回调函数就是在dom节点或组件上挂载函数，函数的入参是dom节点或组件实例，达到的效果与字符串形式是一样的， 都是获取其引用。 如果你将 ref 对象以 &lt;div ref=&#123;myRef&#125; /&gt; 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点 这个 hook的作用：获取Dom操作。如获取一个input的焦点 举个 🌰 See the Pen react useRef by gitducheng (@gitducheng) on CodePen. useContext1const value = useContext(MyContext); useContext接受以一个context对象（React.createContext的返回值）， 并返回当前 Context的当前值。Context的当前值是由上层组件中距离当前组件最近的MyContext.Provider 的value决定。 上面我们提到了 Context对象， 那么这个对象能帮助我们解决什么问题呢？ Context 能解决什么问题在平成的开发过程中，我们进行通信（父子）使用之最多的是 props来进行通信； 但是 跨级组件 的通信我们就不好用 props来通信了。那这时候我们怎么可以把组件状态共享出去呢？ Redux?， 或者 Context react 中的 Context: 在典型的 React 应用程序中，数据通过 props 自上而下（父到子）传递，但对于应用程序中许多组件所需的某些类型的 props（例如环境偏好,UI 主题），这可能很麻烦。 上下文(Context) 提供了在组件之间共享这些值的方法，而不必在树的每个层级显式传递一个 prop 注意：Context主要的应用场景是很多不同层级的组件需要访问同样一些数据， 谨慎使用， 因为这会让组件的复用性变差 创建 Context使用 Context的前提，必须创建它 123import React from &#x27;react&#x27;;export const MyContext = React.createContext(); 使用 Context在使用 Context的时候，它通常用在顶层组件上，它包裹的内部组件都可以享受到 state的使用和修改， 一般是通过 Context.provider来包裹， 通过value来传递。 123456&lt;MyContext.Provider value=&#123;&#123; name &#125;&#125;&gt; &lt;div&gt; &lt;input onChange=&#123;handleName&#125; /&gt; &lt;ComponentA /&gt; &lt;/div&gt;&lt;/MyContext.Provider&gt; 子组件使用 context 传过来的值子组件通过useContext() Hook就可以很方便的拿到值 1const &#123; name &#125; = React.useContext(MyContext); 完整的 🌰 See the Pen react useContext by gitducheng (@gitducheng) on CodePen. useMemo1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 官网文档：useMemo返回的是一个memoized值(具有记忆的值)，useMemo主要是用于性能优化，通过记忆值来避免在每个渲染上进行高开销的计算。 根据官方文档的介绍，我们可以这么理解： 在 a 值 ，b值 不变的情况下，memoizedValue的值不变，也就是useMemo的第一个入参函数不会被执行， 从而达到节省计算量的目的 有两个参数： 第一个是一个回调函数， 主要是暴露出来让我们自己如何去计算这个值的。 第二个参数是一个数组，数组中的state 发生改变才会重新执行回调函数。 注意： 如果不传数组，则每次更新都会重新计算 空数组，只会计算一次 数组里面有依赖值，则当对应的值发生变化时，才会重新计算 举个 🌰 See the Pen react useMemo by gitducheng (@gitducheng) on CodePen. 上面的例子中， 我们点击count 自增 newValue会发生改变； 但是我们点击num 自增 ，newValue是不会发生改变的。 那是因为在useMemo依赖的是 count的变化。 如果没有提供依赖值， 那么useMemo在每次渲染的时候都会重新计算值 useCallback123const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b);&#125;, [a, b]); useCallback返回的是一个 memoized 回调函数(useMemo返回的是memoized值)。 官方文档：把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染 我们可以这么理解： 在 a值, b值不变的情况下，函数 memoizedCallback的引用不变，也就是useCallback的第一个入参加函数会被缓存，从而达到渲染性能优化的目的。 不过能使用useCallback来实现的都能使用useMemo来实现： useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。 有两个参数： 第一个是一个回调函数。 第二个参数是一个数组，数组中的state 发生改变才会重新执行回调函数。 注意： 如果不传数组，则每次更新都会重新计算 空数组，只会计算一次 数组里面有依赖值，则当对应的值发生变化时，才会重新计算 ## 举个 🌰 See the Pen react useCallback by gitducheng (@gitducheng) on CodePen. 整个例子跟useMemo差不多的，只不过useMemo 返回的是值， 而useCallback返回的是一个函数。其功能都是一样的， 当前的依赖项是count， 当count 发生改变时 newValueFn&#96; 会被触发。 关于 useMemo和useCallback的使用场景是什么？ 都有什么作用呢？能优化什么呢？ 这些问题，这篇文章文章会解答： useImperativeHandle1useImperativeHandle(ref, createHandle, [deps]); useImperativeHandle可以在使用ref 的时候自定义暴露给父组件的实例值。在大多数情况下，应当避免使用ref这样的命令式。useImperativeHandle应当与 forwardRef一起使用。 说白了就是子组件暴露给父组件实例使用 有三个参数： 参数 1: 子组件向父组件暴露的实例 参数 2：参数 2 是一个函数，传递的父组件可操作的实例和方法 参数 3: 监听状态， 更新的状态， 可以忽略 举个 🌰 See the Pen react useImperativeHandle by gitducheng (@gitducheng) on CodePen. useLayoutEffectuseLayoutEffect 与 useEffect是差不多的， 它们都是接受一个函数和一个数组， 只有数组里面的值发生了变化， 才会执行effect。 差异： useEffect是异步的，useLayoutEffect 是同步的 useEffect的渲染时机是浏览器完成渲染之后， 而useLayoutEffect 是浏览器把内容真正渲染到浏览器之前，和componentDidMount是等价的。 举个 🌰把useEffect替换成useLayoutEffect几乎是看不到任何问题的。 他们之前的区别是什么呢？ 我们来举个 🌰 使用 useEffect See the Pen react useLayoutEffect by gitducheng (@gitducheng) on CodePen. 上面例子中 点击 div，页面会更新一串随机数。当我们连续点击时，就会发现这串数字在发生抖动。这是因为当我们每次点击 div， count 会更新为 0， 之后 useEffect 内又把 count 改为一串随机数。 所以页面会先渲染成 0，然后再渲染成随机数，由于更新很快，所以出现了闪烁。 刨根问底就是因为：useEffect的渲染时机是浏览器完成渲染之后 使用useLayoutEffect 如果我们把上面的例子改用useLayoutEffect。 我们来看看效果： See the Pen react useLayoutEffect by gitducheng (@gitducheng) on CodePen. 我们可以看出来闪烁消失了。 相比使用 useEffect，当你点击 div，count 更新为 0，此时页面并不会渲染，而是等待 useLayoutEffect 内部状态修改后，才会去更新页面，所以页面不会闪烁。 刨根问底就是因为：useLayoutEffect 是浏览器把内容真正渲染到浏览器之前。 总结 useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。 useEffect 可以满足百分之 99 的场景，而且useLayoutEffect会阻塞渲染，请谨慎使用。 useReducer1const [state, dispatch] = useReducer(reducer, initialArg, init); useReducer是useState的升级版（实际上是原始版）， 可以实现复杂的逻辑修改，而不是像useState那样只是直接赋值修改。 在 React 源码中，实际上useState是由useReducer实现的，所以准确来说useReducer是useState 的原始版 useReducer 通常传入两个参数： 第一个参数：由dispatch引发的数据修改的处理函数 第二个参数：自定义数据的默认值 举个 🌰 See the Pen react useReducer by gitducheng (@gitducheng) on CodePen.","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"关于Delete`CR`eslint(prettier/prettier) 报错的解决方案","slug":"关于Delete`CR`eslint-prettier-prettier-报错的解决方案","date":"2020-06-06T12:47:09.000Z","updated":"2022-07-18T03:18:50.219Z","comments":true,"path":"2020/06/06/关于Delete`CR`eslint-prettier-prettier-报错的解决方案/","link":"","permalink":"http://example.com/2020/06/06/%E5%85%B3%E4%BA%8EDelete%60CR%60eslint-prettier-prettier-%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"问题的提出由于之前是一直使用 mac 笔记本开发，突然使用 windows 开发，发现拉完代码之后， 发现在npm run dev 运行代码之后。发现有如下的问题 1Delete `CR`eslint(prettier/prettier)","text":"问题的提出由于之前是一直使用 mac 笔记本开发，突然使用 windows 开发，发现拉完代码之后， 发现在npm run dev 运行代码之后。发现有如下的问题 1Delete `CR`eslint(prettier/prettier) 问题的根源出现的问题的原因到底是什么呢？ 根据调查发现出问题 : windows下和linux下的文本文件的换行符不一致。 Windows在换行的时候，同时使用了回车符CR(carriage-return character)和换行符LF(linefeed character) 而Mac和Linux系统，仅仅使用了换行符LF 老版本的Mac系统使用的是回车符CR 表格解释如下： Windows Linux&#x2F;Mac Old Mac(pre-OSX) CRLF LF CR ‘\\n\\r’ ‘\\n’ ‘\\r’ 因此，文本文件在不同系统下创建和使用时就会出现不兼容的问题。 所以出现上面的报错是因为我的同事是在mac环境下提交的代码。文件默认是以LF结尾的。 当我使用 Windows 电脑git clone代码的时候， 若我的autocrlf(在windows下安装git，该选项默认为true)为true，那么文件每行会被自动转成以CRLF结尾，若对文件不做任何修改，pre-commit执行eslint的时候就会提示你删除CR。 问题的解决下面是上网查到的各种解决办法以及他们的优缺点。 Crtl+S保存文件按Crtl+S保存当前报错文件，eslint错误消失，但是Git暂存区多了个文件改动记录，对比Working tree没发现任何不同。 缺点：你不可能一一保存所有文件，麻烦，还要commit，多余。 yarn run lint –fix比上面省事，eslint错误消失，但暂存区多了n个文件改动记录，对比Working tree也没发现任何不同。 缺点：需要commit所有文件，多余。 参考的资料：”error Delete ⏎ prettier&#x2F;prettier” in .vue files 配置.prettierrc 文件在项目的根目录的.prettierrc文件中写入即可。其实就是不让prettier检测文件每行结束的格式. 1&quot;endOfLine&quot;: &quot;auto&quot; 缺点：不能兼容跨平台开发，从前端工程化上讲没有做到尽善尽美。 参考的资料：Why do I keep getting Delete ‘cr’ [prettier&#x2F;prettier]? core.autocrlf配置使用git 的一个配置属性： core.autocrlf Git 可以在你提交的时候自动的把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用core.autocrlf来打开此项功能。如果是在Windows 系统上，把它设置为true。这样当签出代码时。LF会被转换成CRLF。 1$ git config --global core.autocrlf true mac 系统使用LF作为行结束符， 因此你不想Git在签出文件时进行自动的转换；当一个CRLF为行结束符的文件不小心被引入时你想修正，把core.autocrlf 设置为input 来告诉Git 在提交的时候把CRLF 转成LF。签出时不转换； 1$ git config --global core.autocrlf input 这样会在Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。 如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中： 1$ git config --global core.autocrlf false 总结遇到问题的时候查找了很多的资料。但是结局的办法都不是很尽美 如方法1，方法 2，方法 3，都存在一定的缺点。 最后一个解决办法才是从灵魂上解决了问题。 所以在解决的问题还是追其根源。从根本上解决问题。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"http协议详解","slug":"http协议详解","date":"2019-09-02T03:52:52.000Z","updated":"2022-07-19T13:24:17.477Z","comments":true,"path":"2019/09/02/http协议详解/","link":"","permalink":"http://example.com/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"在讲http协议之前， 需要先了解一下基础的计算机网络相关知识。 计算机网络体系结构计算机网络体系结构是计算机网络的各层 和 其协议的集合。 在计算机网络的基本概念中，分层次的体系结构是最基本的。 分层相互通信的两个计算机系统必须高度协调工作才行，而这种协调是相当复杂的。为了设计出这样复杂的计算机网络，最初提出了分层的方法。分层可将庞大的而复杂的问题转化为若干较小的局部问题，而这些较小的局部问题比较容易研究和处理。 计算机网络体系结构有三种体系结构： OSI体系结构: 概念清楚，理念完整。但是复杂不实用 TCP/IP体系结构：含了一系列构成互联网基础的协议，是Internet的核心协议。被广泛的使用。 五层体系结构：融合了OSL 与TCP/IP的体系结构， 主要的目的是为了学习，讲解计算机原理。 协议在计算机网络中药做到有条不絮的交换数据，就必须遵守一些事先约定好的规则，这些规则明确了所交换的数据的格式以及有关的同步问题。为网络中的数据交换而建立的规则，标准或者约定称为网络协议，也可以简称为协议 分层和协议就构成了计算机体系结构。 TCP&#x2F;IP体系结构由于TCP&#x2F;IP体系结构运用广泛，所以我们详细讲解下： 层级 作用 具体的协议 应用层 应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务。这里的进程就是指正在运行的程序。 1. http 协议：提供 internet网络浏览服务；2.DNS 协议：负责域名和IP地址的映射3.SMIP协议：提供简单的电子邮件发送服务4.POP 协议：提供对邮箱服务器远程存取邮件的服务。与此功能类似的还有 IMAP 协议5.FIP协议：提供应用级文件传输服务6. SMB协议：提供应用级文件共享服务7.Telnet协议：提供远程登录服务（明文传输）8.SSH协议：提供远程登录服务（加密） 传输层 负责向两个主机中进程之间的通信提供服务 1. TCP协议：提供用户间面向链接，可靠的报文传输服务；2.UDP协议：提供用户间无连接，不可靠的报文传输服务； 网络层 负责为分组交换网上的不同主机提供通信服务 1. IP协议：提供网络结点之前得报文传送服务。2.ARP协议：实现IP呆滞想物理地址的映射3.RARP协议：实现物理地址想IP地址的映射；4.ICMP协议：探测报告传输中产生的错误；5.IGMP协议：管理多波组测成员问题 网络接口层 负责与链路（传输媒介）的数据传输工作。 关于每一层的工作职责还不是哼清楚的可以看这篇文章： 网络各层功能职责——计算机网络 HTTP从上面的内容可以看出http协议是在应用层的。我们先来了解HTTP的基本概念。 HTTP的基本概念HTPP 是超文本传输协议（HyperText Transfer Protocol）。它的名字可以拆解为3个部分： 超文本文本：早起的文本 指的是普调的文本字符，但是现在的文本的含义已经扩展为图片，水平，压缩包等。在HTTP眼里都是文本。 超文本：超越了普调文本的文本，它是图片，文字，视频等的混合体，具有超链接，能从一个超文本跳到另外一个超文本。 HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了 传输 即将数据由A传输到B或者由B传输到A。并且A 与 B 之间可以存放很多第三方；如：A&lt;&#x3D;&gt;X&lt;&#x3D;&gt;Y&lt;&#x3D;&gt;Z&lt;&#x3D;&gt;B 协议 在计算机网络中有很多的协议，HTTP 也是一个协议 那么总结来说：HTTP 是一个在计算机世界里专门在两点之前传输文字，图片， 视频，音频等超文本的数据约定和规定 HTTP协议的原理HTTP协议采用 请求&#x2F;响应的工作方式： HTTP协议工作于客户端-服务端架构上。浏览器最为HTTP客户端通过url向HTTP服务端（web服务器）发送所有的请求 web服务器：Apache服务器，IIS服务器（Internet Information Services）等。 web服务器根据接收到的请求后， 向客户端发送响应信息。 HTTP服务器默认监听的端口号为80，但是也可以设置为其他端口。 一次请求流程简单的来分析，从输入 URL到回车后发生的行为如下： URL解析 DNS查询 TCP连接 HTTP请求 响应请求 页面渲染 TCP关闭 URL 解析首先判断你输入的是不是一个合法的url，并且对你输入的内容进行解析，一个url解析如下： DNS 查询浏览器通过URL解析之后的域名，通过DNS解析出目标网页的IP地址。具体的查询如下： 最终得到域名对应的目标服务器的IP地址 TCP连接在HTTP开始工作之前，客户端和服务端首先会建立连接（TCP三次握手） 发送HTTP请求当建立TCP 连接连接之后，就可以在这基础上进行通信。浏览器发送HTTP请求到服务器。请求的内容包括：请求行，请求头，请求体。这些知识点我们下面会讲到。 响应请求当服务器接收到请求之后，会进行逻辑操作，，处理完之后会返回一个HTTP响应消息，内容包括：响应行， 响应头，响应正文。下面我们会讲到。 页面渲染关于页面的渲染可以看这篇文章： 浏览器的渲染流程 TCP关闭一旦web服务器想浏览器发送了响应数据。它就要关闭TCP连接。但是如果浏览器或者服务器在其头部加入了这行代码Connection： keep-alive那么TCP连接在发送响应数据之后仍然保持打开状态。 HTTP报文详解HTTP在应用层 交互的数据方式 ， 我们叫报文。 HTTP的报文分为：请求报文， 响应报文 请求报文请求报文的结构如下： 一个实际的请求报文如下： 请求报文主要由三个部分组成：请求行， 请求头， 请求体； 请求行声明 请求方法，逐级域名，资源路径&amp;协议版 注意： 空格是不能省略的 请求方法请求方法是定义对请求对象的操作的。请求方法及其解释如下： GET： 向服务器请求指定URL的资源，请求参数是直接带在链接上，所以没有主体; 使用场景：如向数据库查询单个或list数据。 总结来说：告诉服务器我要的东西 POST：用于向服务器提交数据。 使用场景：我新增加一个数据等。 总结来说：告诉服务器我要给的东西 PUT：向服务器请求修改某个已存在的资源。 使用场景： 我要修改用户名等 总结的来说：告诉服务器我要更新。 HEDA：HEAD 和 GET 是差不多的， 只是HEAD 请求的响应报文不返回响应体，只返回响应头。 使用场景 ：某个文件是否存在，检查文件是否更新 DELETE： 向服务器请求删除某个已存在的文件 使用场景: 删除 id 为 23 的的数据 OPTIONS：返回指定URL资源所能够支持的HTTP请求方式。 使用场景：获取服务器支持的 http请求的方式，CORS 中的预检请求 在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。 CONNECT：用于代理用服务器, 具体看这篇文章：HTTP之connect method TRACH: 回显服务器收到的请求 请求路径请求路径就是URL中请求地址的部分. 如：url &#x3D; http://www.baidu.com/；则请求路径为：/； url &#x3D; http://www.baidu.com/20/home，则请求路径为：/20/home。 URL: 是统一资源定位符，它的作用就是表示资源的位置，访问资源的方式。它是由：&lt;协议&gt;：// &lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议版本定义 HTTP 的版本号。 常用的版本号为：HTTP&#x2F;1.0， HTTP&#x2F;1.1，HTTP&#x2F;2.0, 请求头声明 客户端，报文的部分信息。所有的请求头如下： Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text&#x2F;plain, text&#x2F;html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D; Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version&#x3D;1; Skin&#x3D;new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application&#x2F;x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: &#x75;&#115;&#101;&#x72;&#x40;&#101;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d; Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D; Range 只请求实体的一部分，指定范围 Range: bytes&#x3D;500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q&#x3D;0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla&#x2F;5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 请求体存放需要发送的信息 可选部分，如 GET请求就无请求数据 它主要有三种使用方式： 响应报文响应包问的结构如下： 一个实际的响应报文如下： HTTP 响应报文包括：状态行，响应头，响应体。 状态行状态行主要的作用： 声明协议版本，状态码， 状态码描述 注意： 空格不能省略 协议版本定义 HTTP 的版本号。 常用的版本号为：HTTP&#x2F;1.0， HTTP&#x2F;1.1，HTTP&#x2F;2.0, 状态码表示服务器返回的响应状态代码，分为五大类： 1xx: 表示信息通知；如请求收到了， 但是还没处理 2xx: 表示成功。如接受或知道了 3xx: 表示重定向。如果要完成请求还需进一步行动 4xx: 表示客户端错误，请求包含语法错误导致无法实现 5xx: 表示服务器错误，服务器不能实现一种明显无效的请求。 常用的状态码如下： 状态码 状态码英文名称 中文描述 200 OK 请求成功。一般用于GET与POST请求 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 206 Partial Content 是对资源某一部分的请求，服务器成功处理了部分GET请求，响应报文中包含由Content-Range指定范围的实体内容。 301 Moved Permanently 永久性重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时性重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与302类似。使用GET请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向，会按照浏览器标准，不会从POST变成GET。 400 Bad Request 客户端请求报文中存在语法错误，服务器无法理解。浏览器会像200 OK一样对待该状态吗 401 Unauthorized 请求要求用户的身份认证，通过HTTP认证（BASIC认证，DIGEST认证）的认证信息，若之前已进行过一次请求，则表示用户认证失败 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面。也可以在服务器拒绝请求且不想说明理由时使用 500 Internal Server Error 服务器内部错误，无法完成请求，也可能是web应用存在bug或某些临时故障 501 Not Implemented 服务器不支持请求的功能，无法完成请求 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 不常用的HTTP状态码列表 状态码 状态码英文名称 中文描述 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 402 Payment Required 保留，将来使用 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 状态码描述当前状态码的解释消息 响应头响应头的作用：声明服务端的报文的信息 常用的HTTP响应头： 响应头 说明 示例 状态 Access-Control-Allow-Origin 指定哪些网站可以跨域源资源共享 Access-Control-Allow-Origin: * 临时 Accept-Patch 指定服务器所支持的文档补丁格式 Accept-Patch: text&#x2F;example;charset&#x3D;utf-8 固定 Accept-Ranges 服务器所支持的内容范围 Accept-Ranges: bytes 固定 Age 响应对象在代理缓存中存在的时间，以秒为单位 Age: 12 固定 Allow 对于特定资源的有效动作; Allow: GET, HEAD 固定 Cache-Control 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 Cache-Control: max-age=3600 固定 Connection 针对该连接所预期的选项 Connection: close 固定 Content-Disposition 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。 Content-Disposition: attachment; filename&#x3D;”fname.ext” 固定 Content-Encoding 响应资源所使用的编码类型。 Content-Encoding: gzip 固定 Content-Language 响就内容所使用的语言 Content-Language: zh-cn 固定 Content-Length 响应消息体的长度，用8进制字节表示 Content-Length: 348 固定 Content-Location 所返回的数据的一个候选位置 Content-Location: /index.htm 固定 Content-MD5 响应内容的二进制 MD5 散列值，以 Base64 方式编码 Content-MD5: IDK0iSsgSW50ZWd0DiJUi&#x3D;&#x3D; 已淘汰 Content-Range 如果是响应部分消息，表示属于完整消息的哪个部分 Content-Range: bytes 21010-47021&#x2F;47022 固定 Content-Type 当前内容的MIME类型 Content-Type: text&#x2F;html; charset&#x3D;utf-8 固定 Date 此条消息被发送时的日期和时间(以RFC 7231中定义的”HTTP日期”格式来表示) Date: Tue, 15 Nov 1994 08:12:31 GMT 固定 ETag 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列 ETag: “737060cd8c284d8af7ad3082f209582d” 固定 Expires 指定一个日期&#x2F;时间，超过该时间则认为此回应已经过期 Expires: Thu, 01 Dec 1994 16:00:00 GMT 固定: 标准 Last-Modified 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT 固定 Link 用来表示与另一个资源之间的类型关系，此类型关系是在RFC 5988中定义 Link: ; rel&#x3D;”alternate” 固定 Location 用于在进行重定向，或在创建了某个新资源时使用。 Location: http://www.itbilu.com/nodejs 固定 P3P P3P策略相关设置 P3P: CP&#x3D;”This is not a P3P policy! 固定 Pragma 与具体的实现相关，这些响应头可能在请求&#x2F;回应链中的不同时候产生不同的效果 Pragma: no-cache 固定 Proxy-Authenticate 要求在访问代理时提供身份认证信息。 Proxy-Authenticate: Basic 固定 Public-Key-Pins 用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值 Public-Key-Pins: max-age&#x3D;2592000; pin-sha256&#x3D;”……”; 固定 Refresh 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 Refresh: 5; url&#x3D;http://itbilu.com Retry-After 如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT 固定 Server 服务器的名称 Server: nginx/1.6.3 固定 Set-Cookie 设置HTTP cookie Set-Cookie: UserID&#x3D;itbilu; Max-Age&#x3D;3600; Version&#x3D;1 固定: 标准 Status 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。 Status: 200 OK Trailer Trailer用户说明传输中分块编码的编码信息 Trailer: Max-Forwards 固定 Transfer-Encoding 用表示实体传输给用户的编码形式。包括：chunked、compress、 deflate、gzip、identity。 Transfer-Encoding: chunked 固定 Upgrade 要求客户端升级到另一个高版本协议。 Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11 固定 Vary 告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。 Vary: * 固定 Via 告知代理服务器的客户端，当前响应是通过什么途径发送的。 Via: 1.0 fred, 1.1 itbilu.com (nginx&#x2F;1.6.3) 固定 Warning 一般性警告，告知在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning 固定 WWW-Authenticate 表示在请求获取这个实体时应当使用的认证模式。 WWW-Authenticate: Basic 固定 响应体：存放需返回给客户端的数据信息。 跟请求体一样同样分为：任意类型的数据交换格式、键值对形式和分部分形式 HTTP 协议的特点支持客户端&#x2F;服务端模式先去请求的就属于客户端，响应相求的就属于服务端。也就是说：客户端用于请求资源，服务端用于提供资源。 无连接​ HTTP 是无连接的，无连接的含义就是限次每一连接只能处理一个请求， 当服务器响应完客户的请求，并且得到客户端的应答之后，就断开连接。采用这种方式可以节省传输时间。 ​ 早期这么做的原因是 http协议产生与互联网，因此服务器要同时处理成千上万的客户端网页的访问。但是每个客户端与服务器之前得交换数据的间歇比较大。所以导致大部门的通道是空闲的，五段占用了资源。所以HTTP的设计者就利用这种特点将HTTP设计为请求时建立连接，请求万释放连接。已尽快将资源释放出来服务其他客户端。 ​ 随着时间的推移，网页变得复杂，如里面可能嵌入了很多的图片，这时候没访问一次图片都需要建立一个TCP连接。就显得很抵消。因此就出现了请求头 Connection： keep-alive。 用来解决这效率低的问题。 无状态协议对于事物处理没有记忆能力，服务端不知道客户端是什么状态。也就是说我们可以服务器发送HTTP请求之后，服务端会根据请求给我们发送数据过来，但是发送完，不会记录任何的信息。 HTTP是一个无状态的协议，就意味着每个请求都是独立的， keep-alive 也无法改变这个结果。 协议没有状态带来的后果如：访问系统需要登录后才能访问，由于无状态的特点，每次跳转链接都需要重新登录。这就导致每次请求要发送大量的数据信息给服务器。 由于它的这个特点导致很多的问题， 那么用于保持HTTP 有连接状态的技术就有两种：Cookie, Session&#96;； Cookie：是通过在请求头和响应头中写入 Cookie来控制客户端的状态的。首次访问服务端的时候，响应头会返回Set-Cookie的首部字段信息，通知客户保存Cookie。当客户下次再向服务端发送请求的时候，客户端会自动在请求头中加入Cookie值发送给服务端。服务端发现客户端发送过来的Cookie后，会去检查究竟是哪个客户端发送过来的请求，然后对比服务器上的记录，最后得到之前得状态信息。 Session：是通过服务器来保持状态的。当客户端访问服务器时候，服务器设置Session, 将会话信息保存在服务器上，同时将Session的ID传递给客户端浏览器，浏览器会将这个🆔保存在内存中。之后浏览器每次请求都会带上这个参数值，服务器根据Session的ID，就能取掉客户端的信息。 简单快速客户向服务器请求服务时，只需传送请求方法和路径。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活HTTP允许传输任何类型的数据对象。 传输的数据类型由请求头的的Content-type来标记。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"浏览器的渲染流程","slug":"浏览器的渲染流程","date":"2018-03-24T06:56:59.000Z","updated":"2022-07-19T13:20:21.469Z","comments":true,"path":"2018/03/24/浏览器的渲染流程/","link":"","permalink":"http://example.com/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/","excerpt":"导航流程浏览器从输入URL到页面展示间到底发生了什么？这整个流程涉及到网络请求和渲染流程两大块内容。我们可以先看一下总体的导航流程。","text":"导航流程浏览器从输入URL到页面展示间到底发生了什么？这整个流程涉及到网络请求和渲染流程两大块内容。我们可以先看一下总体的导航流程。 浏览器进程构建完整的URL 浏览器进程会检查输入的URL，组装协议，构建完整的的URL 浏览器进程会通过进程间通信（IPC）把URL请求发送网络进程 网络进程发起URL请求 检查本地缓存是有效，如果有有效，则使用本地缓存；如果无效，则进入网络请求流程 网络请求的第一步：DNS解析，获取请求域名的IP地址 和服务器建立TCP链接，并且构建请求信息 服务器接收到请求之后，会构建响应信息 浏览器接收到响应信息后，网络请求会解析响应信息， 若状态码是301&#x2F;302，则会重定向到新的地址，重新发起URL请求 浏览器根据响应的类型（ConTent-Type）进行处理 浏览器进程向渲染进程提交文档 浏览器接收到响应信息后， 会开始准备渲染进程， 同一个站点（同根域名，同协议）会复用同一个渲染进程 浏览器进程准备完毕后，浏览器进程会和渲染进程进行通信，传输文档 渲染进程开始解析页面和加载子资源，完成页面的渲染这个过程就是渲染流程，就是我们本文重点讲的 渲染流程构建DOM树为什么要构建DOM树呢？因为浏览器无法识别HTML，所以需要HTML解析成浏览器识别的数据结构——DOM树。 构建CSSOM树一样的，浏览器也无法识别CSS，所以浏览器会先将CSS解2.jpg析成浏览器能识别的数据结构—styleSheets 然后浏览器会将属性值转化成标准值，因为标准值才容易被渲染引擎理解和使用。 最后，计算DOM树˙中的每个节点的演示， 生成最终的CSSDOM树，这个过程涉及到CSS的继承规则和层叠规则。 构建渲染树（Render Tree），并计算布局将DOM树和CSSDOM树结合就可以得到渲染树。 首先，浏览器会遍历所有可见的元素(像hea这类不可见的标签或者display设置为none的元素等会被排除在外)。 接着，找到节点所适配的的样式并应用， 最终生成渲染树。 即使现在有了渲染树，但是浏览器不知道每个节点的位置信息，所以浏览器会遍历渲染树，计算每个节点的位置信息，这就是计算布局。 分层和绘制经过计算布局之后，并不是立马进行绘制，而是会为有3D或透视变换、z轴排序等复杂效果的节点创建图层，并生成图层树，这样做的目的是方便地实现复杂效果。浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。 什么情况下会创建图层呢？ 有层叠上下文（明确定位属性的元素， 定义透明属性的元素，使用CSS 滤镜） 需要裁剪（overflow: hidden;溢出部分被剪裁） 有了图层树之后，接下来就是绘制图层了。 接着，浏览器会将图层划分为图块，这么做的目的是因为视口显示的内容有限，如果直接将整个结构进行绘制开销比较大，所以浏览器会优先将视口内的图块转为位图，这个过程叫栅格化。 最后，将位图合成，浏览器开始显示。 小结 如上图所示，HTML的渲染过程如下： 将HTML解析为DOM树 将CSS解析为CSSOM树 将DOM树和CSSOM树构建成渲染树，并计算布局 进行分层和绘制 渲染进程的特点回流和绘制回流和绘制是渲染进程比较重要的概念了，了解其中的概念并进行合理的的应用，可以提升性能。 回流当元素的几何属性(尺寸),隐藏属性等改变而触发重新布局的渲染，这个过程就是回流。回流需要更新完整的渲染流程（布局-分层-绘制-图块-栅格化-合成-显示）， 所以开销比较大,需要尽量避免. 触发回流的属性 盒子模型相关属性（width、padding、margin、display、border等） 定位属性和浮动（position、top、float等） 文字结构（text-align、font、white-space、overflow等） 重绘当元素的外观、风格等属性发生改变但不会影响布局的渲染，这个过程就是重绘。重绘省去了布局和分层阶段（绘制-图块-栅格化-合成-显示），所以性能比回流要好。回流必将引起重绘，重绘不一定会触发回流。 触发重绘的属性color，border-style, background，outlinee，box-shadow，visibility， text-decoration 避免回流和重绘频繁触发重绘和回流，会导致UI频繁渲染，最终导致性能变差。所以要尽量避免重绘和回流： 避免使用触发重绘和回流的CSS属性 将频繁重绘回流的元素创建为一个独立图层 技巧 使用transform实现效果：可以避开回流和重绘，直接进入合成阶段（图块-栅格化-合成-显示） 用opacity替代visibility：visibility会触发重绘 使用class替代DOM频繁操作样式 DOM离线后修改，如果有频繁修改，可以先把DOM隐藏，修改完成后再显示 不要在循环中读取DOM的属性值：offsetHeight会使回流缓冲失效 尽量不要使用table布局，小改动会造成整个table重新布局 动画的速度：200~500ms最佳 对动画新建图层 启用GPU硬件加速：启用translate3D HTML解析的特点顺序执行，并发加载 顺序执行：HTML的词法分析事从上到下， 顺序执行 并发加载：当HTML解析被脚本阻碍时，解析器虽然会停止构建DOM，但仍会识别脚本后面的内容，并进行加载 并发上限：浏览器对同域名的并发数是有限制的 阻塞css阻塞 css 在head中阻塞页面的渲染：避免页面闪动 css会阻塞jsd的执行：CSSOM构建的时候，Javascript执行将被暂停，知道CSSDOM构建完成 css不会阻塞外部脚本的加载 js阻塞 直接引入的js会阻塞页面的渲染：当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行 js不阻塞资源的加载 js顺序执行，会阻塞后续js的执行 js可以查询和修改 DOM 与 CSS 改变js的阻塞defer和async属性可以改变js的阻塞情形，不过这两个只对src方式引入的script有效，对于inline-script无效。 defer表示延迟执行，浏览器会异步地加载该脚本并且不会影响到后续DOM的渲染，该脚本将在文档完成解析后，DOMContentLoaded事件触发前执行。对动态嵌入的脚本使用 async=false 来达到类似的效果。 async表示异步执行，浏览器会异步地加载脚本并在允许的情况下执行。与 defer 的区别在于，无论是 HTML 解析阶段还是DOMContentLoaded触发之后，如果脚本加载完成，就会开始执行。需要注意的是，这种方式加载的 JavaScript 依然会阻塞load事件。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}],"categories":[{"name":"云主机","slug":"云主机","permalink":"http://example.com/categories/%E4%BA%91%E4%B8%BB%E6%9C%BA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"云主机","slug":"云主机","permalink":"http://example.com/tags/%E4%BA%91%E4%B8%BB%E6%9C%BA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}