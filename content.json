{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-06-27T06:02:02.400Z","updated":"2022-06-27T06:02:02.400Z","comments":true,"path":"about/index.css","permalink":"http://example.com/about/index.css","excerpt":"","text":"body, html { width: 100%; height: 100%; margin: 0; } .container { width: 100%; height: 100%; overflow: auto; position: relative; background: #fff; } .page-header { display: flex; justify-content: space-between; position: absolute; top: 0; z-index: 99; box-sizing: border-box; padding: 10px 36px; width: 100%; border: none; font-size: 18px; -webkit-transition: all 0.2s ease-in-out; -moz-transition: all 0.2s ease-in-out; -o-transition: all 0.2s ease-in-out; -ms-transition: all 0.2s ease-in-out; transition: all 0.2s ease-in-out; } .page-header a { color: #eee; text-decoration: none; } .site-name { text-shadow: 0.1rem 0.1rem 0.2rem rgb(0 0 0 / 15%); font-weight: bold; cursor: pointer; color: #eee; text-decoration: none; } .toggle-menu { display: none; padding-top: 0.5rem; color: #eee; cursor: pointer; -webkit-transition: all 0.2s ease-in-out; -moz-transition: all 0.2s ease-in-out; -o-transition: all 0.2s ease-in-out; -ms-transition: all 0.2s ease-in-out; transition: all 0.2s ease-in-out; } .site-page { position: relative; margin-left: 0.6rem; padding-bottom: 0.3rem; text-shadow: 0.05rem 0.05rem 0.1rem rgb(0 0 0 / 30%); font-size: 14px; cursor: pointer; } .site-page:hover { border-bottom: 2px solid #fff; } .content { width: 100%; height: calc(100% - 50px); margin-top: 50px; display: flex; justify-content: center; align-items: center; } .card { display: flex; justify-content: space-between; width: 800px; height: 600px; border-radius: 7px; background: #fff; overflow: hidden; box-shadow: 0 0 11px 3px rgb(0 0 0 / 15%); } .card_left { flex: 300px 1 0; padding-top: 10%; box-sizing: border-box; background: #f8f8fb66; text-align: center; border-right: 1px solid #e6e6e6; } .card_left .avatar { width: 200px; height: 200px; border-radius: 100%; transform: scale(1); } @keyframes scale { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } } @keyframes scale { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } } .avatar:hover { -moz-box-shadow: 0px 0px 25px #6c97b1; -webkit-box-shadow: 0px 0px 25px #6c97b1; box-shadow: 0px 0px 25px #6c97b1; cursor: pointer; animation: scale 1s; } .card_right { padding: 20px; background: #f8f8fb66; } .right_container { width: 100%; height: 100%; color: #333; overflow: scroll; } .item { margin-top: 30px; } .item:first-child { margin-top: 0; } .title { font-size: 18px; font-weight: 500; color: #222; font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e5e5e5; } .page { font-size: 15px; } .github { width: 40px; height: 40px; border-radius: 100%; } .right_container a { color: #333; } .right_container a:hover { color: #49b1f5; }"},{"title":"关于我","date":"2022-06-27T07:30:10.000Z","updated":"2022-06-27T06:14:48.752Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Pydc的博客 Pydc的Blog 首页 归档 分类 标签 关于 Pydc 一只正在努力学习前端的小菜鸟 关于博客 博客主要记录平时自己学习的知识点。记录工作中遇到的点点滴滴知识点。规定自己一个月至少一篇博客，鞭策自己要不断的学习！ 关于我 喜欢看热度高的电影，有意思的动漫，已完结的漫画，各个平台的游戏（除了PS），有用的技术，CTF...... 关于工作 2021.7-至&nbsp;&nbsp;&nbsp;今：字节跳动 2019.6-2021.7：中信银行 个人信息 学校：中南民族大学 专业：计算机科学与技术 时间：2019年毕业 职业：web前端开发 城市：北京 联系方式 邮箱：1147914778@qq.com"},{"title":"标签","date":"2022-06-24T03:14:06.843Z","updated":"2022-06-24T03:14:06.843Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-06-24T06:40:33.432Z","updated":"2022-06-24T06:40:33.432Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue2.x的生命周期详解","slug":"Vue2-x的生命周期详解","date":"2022-06-17T11:31:36.000Z","updated":"2022-06-27T06:49:00.428Z","comments":true,"path":"2022/06/17/Vue2-x的生命周期详解/","link":"","permalink":"http://example.com/2022/06/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"使用Vue开发已经有一段时间了。但发现自己对vue的理解还是不深刻。于是想着从观看Vue文档开始。在阅读文档之前，觉得需要先了解整个Vue的生命周期，清楚的认识到Vue在每个阶段的钩子函数没这样才能更好的让我们去使用Vue。 我们先来看一张图，上面解释每个步骤是做什么的。可以只看这一张图就可以明白Vue实例的整个流程。 每个Vue实例在被创建之前都要经历过一系列的初始化过程，这个过程就是Vue的生命周期。浅显的来说，生命周期的钩子函数就是回调函数，在不同的阶段有不同的回调函数供用户处理自定义的事件。也可以说生命周期是一套流程，而这套流程里面的方法会有先后顺序的执行（调用就执行，不调用就不执行）。 生命周期钩子从上面的图中会看到生个vue的生命周期钩子： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 当然除了实例的生命周期，还有其他的： activated： keep-alive 缓存组件激活时使用 deactivated： keep-alice 缓存组件停用时使用 errorCaptured： 捕获一个来自子孙组件的错误时调用 beforeCreate 之前在beforeCreate生命周期之前。首先是使用new Vue来开始创建一个Vue实例、接下来会初始化这个实例的生命周期事件。如下图： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, beforeCreate () &#123; console.log(&quot;------beforeCreate------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data); console.log(&quot;methods:&quot;, this.getMessage); &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 打印结果： 1234------beforeCreate------el: undefineddata: undefinedmethods: undefined beforeCreate 和 created 之间在这个生命周期之前，会初始化当前实例上的data 和methods。说明created的时候数据已经绑定，是可以访问到了。在这里可以做ajax请求了。 注意：这里还没有 el 选项。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, beforeCreate () &#123; console.log(&quot;------beforeCreate------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data); console.log(&quot;methods:&quot;, this.getMessage); &#125;, created () &#123; console.log(&quot;------created------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data.message); console.log(&quot;methods:&quot;, this.getMessage()); &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 结果打印： 12345678------beforeCreate------el: undefineddata: undefinedmethods: undefined------created------el: undefineddata: Pydcmethods: 方法返回：Pydc 可以看出，created可以获取data和methods created 和 beforeMount 之间的生命周期 这阶段里面首先会判断是否有el选项。如果有的话，那么继续往下编译，如果没有el选项。则停止编辑。也就意味停止了生命周期。直到该Vue实例上调用了Vm.$mount(el)。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; // el: &#x27;#app&#x27;, // 被注释掉了 data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, created() &#123; console.log(&quot;------created--------&quot;) &#125;, beforeMount() &#123; console.log(&quot;------beforeMount------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data.message) console.log(&quot;methods:&quot;, this.getMessage()); &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 结果打印： 1------created-------- 手动调用实例的Vm。$mount(#app): 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; // el: &#x27;#app&#x27;, // 被注释掉了 data: &#123; message: &quot;Pydc&quot; &#125;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, created() &#123; console.log(&quot;------created--------&quot;) &#125;, beforeMount() &#123; console.log(&quot;------beforeMount------&quot;); console.log(&quot;el:&quot;, this.$el); console.log(&quot;data:&quot;, this.$data.message) console.log(&quot;methods:&quot;, this.getMessage()); &#125;, &#125;) vm.$mount(&quot;#app&quot;); // 手动调用了 Vm.$mount(el)&lt;/script&gt;&lt;/html&gt; 结果打印： 然后会判断是否有template。有没有template对生命周期没有影响。 如果有template则直接作为模板编译成render函数； 如果没有template则直接将外部的html作为模板编译； 注意：template模板的优先级要高于外部html的优先级。 如下的例子： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;这是外部的html模板:&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, template: &quot;&lt;span&gt;这是内部的模板：&#123;&#123;message&#125;&#125;&lt;/span&gt;&quot;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 打开之后，我们看到的页面文案是：”这是内部的模板：Pydc” 如果我们把template 删除掉那么就会显示：”这是外部的html模板:Pydc”6 beforeMount 和 mounted之前的生命周期 这期间Vue实例对象添加$el。把内存中渲染好的html 替换到页面上。覆盖$el指定的页面。因为在这之前的beforeCreate生命周期打印的el还是undefined。 mounted生命周期12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;这是外部的html模板:&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;Pydc&quot; &#125;, template: &quot;&lt;span&gt;这是内部的模板：&#123;&#123;message&#125;&#125;&lt;/span&gt;&quot;, methods: &#123; getMessage() &#123; return `方法返回：$&#123;this.message&#125;`; &#125; &#125;, mounted() &#123; console.log(&quot;--------mounted--------&quot;); console.log(&quot;el:&quot;, this.$el); &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 打印结果为： 12--------mounted--------el: &lt;span&gt;​这是内部的模板：Pydc​&lt;/span&gt;​ 在这之前的span标签的名字是 占位的。这是JavaScript中的虚拟DOM形式存在的。在mounted之后就可以看到了内容发生了变化。 beforeUpdate 和 updated 之间的生命周期 从图中可以看出来， 当data的数据发生了变化，先会触发beforeUpdate钩子。注意这时候页面的视图还没更新。然后才重新渲染组件。最后调用updated。调用完之后。视图和data都是最新的。 我们看下面的例子： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue2.x生命周期学习&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;这是外部的html模板:&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;老的数据&quot; &#125;, beforeUpdate() &#123; console.log(&quot;--------beforeUpdate--------&quot;); console.log(&quot;el:&quot;, this.$el); &#125;, updated() &#123; console.log(&quot;--------updated--------&quot;); console.log(&quot;el:&quot;, this.$el); &#125; &#125;) vm.message = &quot;新的数据&quot;;&lt;/script&gt;&lt;/html&gt; 打印结果： 当数据data有改变的（ vm.message &#x3D; “新的数据”）。就会分别触发beforeUpdate 和 updated。 beforeDestroy 和 destroyed 之间的生命周期 beforeDestroy 生命周期是在实例被销毁之前调用。在这一步，实例仍然是可用的。 destroyed生命周期是在实例销毁之后调用。调用后。Vue实例所指的所有东西都会被解除绑定。所有的事件也会被移除。所有的子实例也会被销毁。 activatedkeep-alive 缓存组件激活的时候使用 deactivated keep-alive 缓存组件停用时使用 errorCaptured捕获子孙组件的错误时调用 数据请求在created和mouted的区别created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成，mounted是在页面dom节点渲染完毕之后就立刻执行的，触发时机上created是比mounted要更早的：两者相同点：都能拿到实例对象的属性和方法；讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在create生命周期当中","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]}